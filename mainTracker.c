/*  
  mainTracker.c - the brains of the operation
  
  Takes input in the form of background model and then tracks people within a webcam feed or recorded video
  Does 3D tracking when depth data is supplied
  
  Required for 2D tracking:
    webcam OR a video in uncompressed avi format
    backMean.xml - statistical model of background, generated by Matlab program (mean)
    backCov.xml  - statistical model of background, generated by Matlab program (covariance)
    
  Optional for 3D tracking:
    stereo displacement video (uncompressed avi) generated by stereoProcess.c
    
    
  Contained functions:
    main()              - executes the main get frame/classify/update condensation/display loop
    drawPositionTrail() - draws the x,z positions in a window
    drawTrackingBoxes() - draws tracking boxes around subjects, based on particle filtering results
    drawHeatmap()       - draws map of likelihoods; whiter values are more likely to belong to foreground
    drawSpecial()       - experiment, draws foreground pixels as blue
    depthRectangle()    - calculates the depth of the object contained within the input rectangle
    

  2010-2011  Will Dollman <willdollman@gmail.com>
  
*/


#include <stdio.h>
#include <highgui.h>
#include <cv.h>
#include <cxcore.h>
#include <math.h>
#include <cvaux.h>

#include "mainTracker.h"
#include "particleFilter.c"
#include "imageLikelihood.c"

#include <time.h>//


unsigned char getPixel( IplImage* stereoFrame, int x, int y );
void drawHeatmap( int maxBox[10], CvMat *imgLikelihood, IplImage* heatFrame );

void drawTrackingBoxes( int personNum, int maxBox[10], 
                        IplImage* frame, IplImage* stereoFrame );

void drawPositionTrail( int maxBox[10], int trailLength, 
                        int depth[2], int planX1Pos[20], 
                        int planX2Pos[20], int planZ1Pos[20], int planZ2Pos[20], 
                        IplImage* positionFrame );

                        
void drawSpecial( CvMat *imgLikelihood, IplImage* specialFrame );

void initCaptureFiles( int argc, char *argv[], CvCapture **capture, CvCapture **stereoCapture, int *webcamRun, int *enable3D );




// need to return positive or negative
void initCaptureFiles( int argc, char *argv[], CvCapture **capture, CvCapture **stereoCapture, int *webcamRun, int *enable3D ) {
    if( argc < 3 ) {;
        printf("Incorrect arguments:\n");
        printf("Webcam: mainTracker mean.xml cov.xml\n");
        printf("2D video: mainTracker mean.xml cov.xml video.avi");
        printf("3D video: mainTracker mean.xml cov.xml video.avi stereo.avi\n");
        
        exit(1);
    }


    char locationVideoActual[300];
    char locationVideoStereo[300];
    
    if( argc == 3 ) {
        printf("Running on webcam\n");
        *webcamRun = 1;
    } else if( argc == 4 ) {
        strncpy( locationVideoActual, argv[3], 300 );
    } else if( argc == 5 ) {
        strncpy( locationVideoActual, argv[3], 300 );
        strncpy( locationVideoStereo, argv[4], 300 );
    } else {
        printf("Incorrect arguments:\n");
        printf("Webcam: mainTracker mean.xml cov.xml\n");
        printf("2D video: mainTracker mean.xml cov.xml video.avi");
        printf("3D video: mainTracker mean.xml cov.xml video.avi stereo.avi\n");
        
        exit(1);
    }
    
    
    if( *webcamRun ) {
        *capture       = cvCaptureFromCAM(0);
        *stereoCapture = cvCreateFileCapture( "nonexistantfile.avi" );
    } else {
        *capture       = cvCreateFileCapture( locationVideoActual );
        *stereoCapture = cvCreateFileCapture( locationVideoStereo );
    }
    
    if ( !*capture ) {
       fprintf( stderr, "Cannot open regular video file\n" );
       exit(1);
  } else {
       fprintf( stderr, "\nRegular video loaded ok\n" );
  }
  
  if ( *stereoCapture ) {
    printf("Depth file found, enabling 3D tracking\n");
    *enable3D = 1;
  } else {
    fprintf( stderr, "Could not open depth file, using 2D tracking" );
    *enable3D = 0;
  }
         
}
                 

        



int main( int argc, char *argv[] ) {

    int webcamRun = 0;
    
    CvCapture *capture = 0;
    CvCapture *stereoCapture = 0;
    
    CvCapture **cptPtr = &capture;
    CvCapture **scptPtr = &stereoCapture;
    
    initCaptureFiles( argc, argv, cptPtr, scptPtr, &webcamRun, &enable3D );
  
  
  
  char locationMean[300];
  char locationCov[300];
  strncpy( locationMean, argv[1], 300 );
  strncpy(  locationCov, argv[2], 300 );
  
  
  
  /* check for stereo file */  
  
  
  
  if( !enable3D ) {
    displayStereoFrame   = 0;
    displayPositionFrame = 0;
    depthScaling         = 0;
  }
  
    
  /* Fast-forwards through the video to the action */
  int kl;
  for( kl = 0; kl < 100 && webcamRun == 0; kl++ ) {
    cvQueryFrame( capture );
    if( enable3D ) cvQueryFrame( stereoCapture );
  }
    
    
  /*
      Housekeeping
  */
  
  int maxBox[10];
  // this should be in the relevant file
  //! Create matrix files to hold intermediate calculations for likelihood
  
  
  
  


  /* this should have its own matrix setup function and not be hard-coded */
  //! Create N-dimensional matrices to hold mean and cov data
  int backMeanSizes[] = {_sizeY,_sizeX,4,_numResponses};
  int backCovSizes[]  = {_sizeY,_sizeX,4,_numResponses};

  CvMatND *backMean = cvCreateMatND( 4, backMeanSizes, CV_32F );
  CvMatND *backCov  = cvCreateMatND( 4, backCovSizes,  CV_32F );

  /* Fix this */
  if( webcamRun ) {
    backMean = (CvMatND*) cvLoad( "D:/Will/Dropbox/My Dropbox/Project/Matlab/backMean.xml", NULL, NULL, NULL );
    backCov  = (CvMatND*) cvLoad( "D:/Will/Dropbox/My Dropbox/Project/Matlab/backCov.xml", NULL, NULL, NULL );
  } else {
    backMean = (CvMatND*) cvLoad( locationMean, NULL, NULL, NULL );
    backCov  = (CvMatND*) cvLoad( locationCov, NULL, NULL, NULL );
  }
  
  /* end here */
  
  
  CvMat *imgLikelihood = cvCreateMat( 48, 64, CV_32F );
  


  img  = cvLoadImage( "foreground8/image (1).jpg", CV_LOAD_IMAGE_COLOR );
  yImg = cvLoadImage( "foreground8/image (1).jpg", CV_LOAD_IMAGE_COLOR );
  cvNamedWindow( "Tracker", CV_WINDOW_AUTOSIZE );
  
  
  /* Condensation stuff */
  ConDens = cvCreateConDensation( DP, MP, nSamples );
  
  bx = 320; by = 240;
	//hm = 0; //vm = 0;

  /* Initialize the random number generator */
	rng_state = cvRNG(0xffffffff);
 
  initializeCondensation();
  
  /* This allows us to change the probabiity with which Condensation alters each variable */
  cvRandInit( &(ConDens->RandS[0]), -75, 75, 0, CV_RAND_UNI);
  cvRandInit( &(ConDens->RandS[1]),  -5,  5, 1, CV_RAND_UNI);
  cvRandInit( &(ConDens->RandS[2]),  -5,  5, 2, CV_RAND_UNI);
  cvRandInit( &(ConDens->RandS[3]),  -2,  2, 3, CV_RAND_UNI);
  
  cvRandInit( &(ConDens->RandS[4]), -75, 75, 4, CV_RAND_UNI);
  cvRandInit( &(ConDens->RandS[5]),  -5,  5, 5, CV_RAND_UNI);
  cvRandInit( &(ConDens->RandS[6]),  -5,  5, 6, CV_RAND_UNI);
  cvRandInit( &(ConDens->RandS[7]),  -2,  2, 7, CV_RAND_UNI);
  
  /*
    If we have depth scaling, the depth controls the width & height of the box
    So we don't want any randomness
  */
  if( depthScaling ) {
    cvRandInit( &(ConDens->RandS[3]),  0,  0, 3, CV_RAND_UNI);
    cvRandInit( &(ConDens->RandS[7]),  0,  0, 7, CV_RAND_UNI);
  }

  
  IplImage* heatFrame = NULL;
  heatFrame = cvQueryFrame( capture );
  if(enable3D) cvQueryFrame( stereoCapture ); // making sure they stay in sync (and init positionFrame)
  
  
  int frameNumb = 0;
  // int mjk;
  // for( mjk = 0; mjk < 320; mjk++ ) {
    // cvQueryFrame( capture );
    // cvQueryFrame( stereoCapture );
    // frameNumb++;
  // }
  

  
  positionFrame = cvCreateImage(cvSize(640, 510), 8, 3);
  
  
  int trailLength = 20;
  int planX1Pos[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  int planX2Pos[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  int planZ1Pos[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  int planZ2Pos[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  

  int key = 0;
  double totalTime = 0;
  int totalFrames = 0;
  
  
  
  while( key != 'q' ) {
  
    // stopCount++;
    // strcpy(frameNameTemp, frameName);
    // itoa(stopCount, frameCount, 10);
    // strcat( frameNameTemp, frameCount);
    // strcat(frameNameTemp, ".jpg");
    // cvSaveImage(frameNameTemp, positionFrame, 0);
    
    
    /* Start timing */
    clock_t start = clock();
        
        frameNumb++;
        printf("Frame %d\n", frameNumb);
        if( frameNumb == 210 ) {
          for( ; frameNumb < 290; frameNumb++ ) {
            cvQueryFrame( capture );
            cvQueryFrame( stereoCapture );
          }
        }
        
        if( frameNumb == 350 ) {
          return(0);
        }
        
        /* Get the first video frame, and maybe stereo frame */
        frame = cvQueryFrame( capture );
        if(enable3D) stereoFrame = cvQueryFrame( stereoCapture );
        
        
        /* Double-check that we haven't reached the end */
        if( !frame ) break;
        if( enable3D ) if( !stereoFrame ) break;
        
        
        /* Compute likelihoods for new frame, using mean and cov */
        likelihood( frame, backMean, backCov, imgLikelihood );
        
        /* Update the Condensation model using new likelihoods */
        updateCondensation( 0, 0, imgLikelihood, maxBox );

        /* Maybe display the Condensation particles */
        if( displayParticles ) 
          drawParticles();

        /* Draw tracking boxes onto the video and stereo video frame */
        drawTrackingBoxes( 0, maxBox, frame, stereoFrame );
        drawTrackingBoxes( 1, maxBox, frame, stereoFrame );

        /* Show the latest video frame (with boxes and particles) */
        cvShowImage( "Tracker", frame );

        /* Maybe show latest stereo depth frame */
        if( displayStereoFrame )
          cvShowImage( "Stereo", stereoFrame );
      
        /* Maybe show latest position map */
        if( displayPositionFrame )
          drawPositionTrail( maxBox, trailLength, 
                             depth, 
                             planX1Pos, planX2Pos, planZ1Pos, 
                             planZ2Pos, positionFrame );
        
        /* Maybe show the heat map of the input image (the likelihood for each patch) */
        if( displayHeatFrame ) {
          drawHeatmap( maxBox, imgLikelihood, heatFrame );
          cvShowImage( "Heat", heatFrame );
        }
        
        /* Update previous x, y positions */
        prevX[0] = maxBox[0]; prevY[0] = maxBox[1];
        prevX[1] = maxBox[4]; prevY[1] = maxBox[5];
        
        
        /* Calculate fps and average fps */
        printf("fps: %3.1f, ", (double)1/(((double)clock() - start) / CLOCKS_PER_SEC));
        totalTime = totalTime + (double)1/(((double)clock() - start) / CLOCKS_PER_SEC);
        totalFrames++;
        printf(" average fps %3.1f", totalTime/totalFrames);
        
        /* Check for key presses */
        key = cvWaitKey( 50 );
        
        /* Enable debugging mode */
        if( key == 'd' ) {
          debug = 1;
          printf("\n*********\n\nDebug: ON\n\n*********\n");
        }
        
        /* Enable debugging mode */
        if( key == 'p' ) {
          if( stateDraw )
            stateDraw = 0;
          else
            stateDraw = 1;
          printf("\n*********\n\nParticle Drawing Toggled\n\n*********\n");
        }

    }
  
  printf("\n\nquitting");

//cvReleaseVideoWriter( &writerTracker );
cvReleaseImage( &img );
cvReleaseImage( &frame );
cvDestroyWindow( "Tracker" );
cvDestroyWindow( "Heat" );
cvDestroyWindow( "Stereo" );
cvDestroyWindow( "Position" );

return(0);

}





//! Draw the position window - displays the x,z position of tracked objects

void drawPositionTrail( int maxBox[10], int trailLength, 
                        int depth[2], int planX1Pos[20], 
                        int planX2Pos[20], int planZ1Pos[20], int planZ2Pos[20], 
                        IplImage* positionFrame )
{

  int xzPos;
  
  cvCircle( positionFrame, cvPoint( planX1Pos[0], planZ1Pos[0] ), 5, CV_RGB ( 0, 0, 0 ) , 1,8,0);
  cvCircle( positionFrame, cvPoint( planX2Pos[0], planZ2Pos[0] ), 5, CV_RGB ( 0, 0, 0 ) , 1,8,0);
  
  /* Move all objects up the "queue" */
  for( xzPos = 0; xzPos < trailLength; xzPos++ ) {
    planX1Pos[xzPos] = planX1Pos[xzPos+1];
    planX2Pos[xzPos] = planX2Pos[xzPos+1];
    planZ1Pos[xzPos] = planZ1Pos[xzPos+1];
    planZ2Pos[xzPos] = planZ2Pos[xzPos+1];
  }
  
  /* Depending on whether an object was found, add their position or don't */
  if( person[0] ) {
    planX1Pos[trailLength-1] = maxBox[0];
    planZ1Pos[trailLength-1] = depth[0] * 2;
  } else {
    planX1Pos[trailLength-1] = 1000;
    planZ1Pos[trailLength-1] = 1000;
  }
  if( person[1] ) {
    planX2Pos[trailLength-1] = maxBox[4];
    planZ2Pos[trailLength-1] = depth[1] * 2;
  } else {
    planX2Pos[trailLength-1] = 1000;
    planZ2Pos[trailLength-1] = 1000;
  }
  
  /* Blank out the previous image */
  /* Build new image frame using "queue", with fancy fade transitions */
  for( xzPos = 0; xzPos < trailLength; xzPos++ ) {
    if( xzPos == trailLength - 1 ) {
      cvCircle( positionFrame, cvPoint( planX1Pos[xzPos], planZ1Pos[xzPos] ), 5, CV_RGB ( 255, 255, 255 ) , 1,8,0);
      cvCircle( positionFrame, cvPoint( planX2Pos[xzPos], planZ2Pos[xzPos] ), 5, CV_RGB ( 255, 0, 0 ) , 1,8,0);
    } else {
      cvCircle( positionFrame, cvPoint( planX1Pos[xzPos], planZ1Pos[xzPos] ), 5, CV_RGB ( (xzPos*7)+94, (xzPos*7)+94, (xzPos*7)+94 ) , 1,8,0);
      cvCircle( positionFrame, cvPoint( planX2Pos[xzPos], planZ2Pos[xzPos] ), 5, CV_RGB ( (xzPos*7)+94, 0, 0 ) , 1,8,0);
    }
  }
        
  // Display our hard work
  if( displayPositionFrame ) cvShowImage( "Position", positionFrame );
  
  
}




//! Draw boxes around the subjects we've found

void drawTrackingBoxes( int personNum, int maxBox[10], IplImage* frame, IplImage* stereoFrame ) {

  int process = 0;
  int colour[3];
  int base = personNum * 4;

  // hack while we still refer to them as persons p and q
  if( personNum == 0 ) {
    if( person[0] == 1 ) {
      process = 1;
    }
    colour[0] = 255; colour[1] = 255; colour[2] = 255;
  } else if (personNum == 1 ) {
    if( person[1] == 1) {
      process = 1;
    }
    colour[0] = 255; colour[1] = 0;   colour[2] = 0;
  }
  
  
  /* if 3D is enabled, get the depth within this rectangle */
  if( enable3D ) depth[personNum] = depthRectangle( cvPoint(maxBox[base+0], maxBox[base+1] ), cvPoint( maxBox[base+0] + maxBox[base+2], maxBox[base+1] + maxBox[base+3] ) );
  
  /* Cap minimum depth to prevent box scaling problems */
  if( depth[personNum] < minDepth )
    depth[personNum] = minDepth;
  
  
  if(personNum==0) printf("\nDepth: %d | ",depth[0]);
  if(personNum==1) printf("%d\n",depth[1]);
  
  // 'process' refers to whether the object was found or not
  if( process ) {
    
    /* draw the body box in the stereo window */
    if( displayStereoFrame ) cvRectangle(stereoFrame, cvPoint(maxBox[base+0], maxBox[base+1] ), cvPoint(maxBox[base+0] + maxBox[base+2], maxBox[base+1] + maxBox[base+3] ), CV_RGB ( colour[0], colour[1], colour[2] ),1, 8, 0);
    
    /* draw the body box in the video window */
    cvRectangle(frame, cvPoint(maxBox[base+0], maxBox[base+1] ), cvPoint(maxBox[base+0] + maxBox[base+2], maxBox[base+1] + maxBox[base+3] ), CV_RGB ( colour[0], colour[1], colour[2] ),4, 8, 0);
    
    /* draw the head box in the video window */
    cvRectangle(frame, cvPoint( maxBox[base+0] + ( maxBox[base+2]/3 ), maxBox[base+1] - ( maxBox[base+3]/4 ) ), cvPoint( maxBox[base+0] + ( 2*maxBox[base+2]/3 ), maxBox[base+1] ), CV_RGB ( colour[0], colour[1], colour[2] ),4, 8, 0);
    
    /* draw the speed box in the video window */
    cvRectangle(frame, cvPoint( maxBox[base+0] , maxBox[base+1] ), cvPoint( maxBox[base+0] + maxBox[personNum+8], maxBox[base+1] + 10 ), CV_RGB ( colour[0], colour[1], colour[2] ),1, 8, 0);
    
  }
  
}


//! Displays the likelihood of each patch. Ligher = more likely to be foreground object
void drawHeatmap( int maxBox[10], CvMat* imgLikelihood, IplImage* heatFrame ) {
  
  int xHeat, yHeat, tempHeat, heatColour;

  // For every patch, threshold the values and assign a shade of white/grey
  for( yHeat = 0; yHeat < 48; yHeat++ ) {
    for( xHeat = 0; xHeat < 64; xHeat++ ) {
      tempHeat = cvGetReal2D( imgLikelihood, yHeat, xHeat );
      
      if( shadowRemove ) {
        if( tempHeat < 15)
          heatColour = 0;
        else if( tempHeat < 30)
          heatColour = 70;
        else if( tempHeat < 70)
          heatColour = 120;
        else if( tempHeat < 100)
          heatColour = 175;
        else if( tempHeat >= 200)
          heatColour = 255;
      } else {
        if( tempHeat < 200)
          heatColour = 0;
        else if( tempHeat < 600)
          heatColour = 70;
        else if( tempHeat < 1000)
          heatColour = 120;
        else if( tempHeat < 1400)
          heatColour = 175;
        else if( tempHeat >= 1400)
          heatColour = 255;
      }

      // display a rectange of that colour
      cvRectangle(heatFrame, cvPoint(xHeat*10, yHeat*10 ), cvPoint(xHeat*10+9, yHeat*10+9 ), CV_RGB ( heatColour, heatColour, heatColour ),CV_FILLED, 8, 0);
      
      //if( special && heatColour < 175 ) cvRectangle(specialFrame, cvPoint(xHeat*10, yHeat*10 ), cvPoint(xHeat*10+9, yHeat*10+9 ), CV_RGB ( 0, 0, 0 ),CV_FILLED, 8, 0);
              
    }
  }
  
  
  // draw tracking rectanges - different to the others in that they will always be there
  // even if we haven't found an object to track
  /* Don't need to be shown in the final version */
  /*
  cvRectangle(heatFrame, cvPoint(maxBox[0], maxBox[1] ), cvPoint(maxBox[0] + maxBox[2], maxBox[1] + maxBox[3] ), CV_RGB ( 255, 255, 255 ),1, 8, 0);
  cvRectangle(heatFrame, cvPoint( maxBox[0] + ( maxBox[2]/3 ), maxBox[1] - ( maxBox[3]/4 ) ), cvPoint( maxBox[0] + ( 2*maxBox[2]/3 ), maxBox[1] ), CV_RGB ( 255, 255, 255 ),1, 8, 0);

  cvRectangle(heatFrame, cvPoint(maxBox[4], maxBox[5] ), cvPoint(maxBox[4] + maxBox[6], maxBox[5] + maxBox[7] ), CV_RGB ( 255, 0, 0 ),1, 8, 0);
  cvRectangle(heatFrame, cvPoint( maxBox[4] + ( maxBox[6]/3 ), maxBox[5] - ( maxBox[7]/4 ) ), cvPoint( maxBox[4] + ( 2*maxBox[6]/3 ), maxBox[5] ), CV_RGB ( 255, 0, 0 ),1, 8, 0);
  */
          
}



//! Draw foreground patches as blue
void drawSpecial( CvMat* imgLikelihood, IplImage* theFrame ) {
  
  int xHeat, yHeat, tempHeat, heatColour;
  IplImage *specialFrame = 0;
  
  specialFrame = cvCloneImage( theFrame );

  // For every patch, threshold the values and assign a shade of white/grey
  for( yHeat = 0; yHeat < 48; yHeat++ ) {
    for( xHeat = 0; xHeat < 64; xHeat++ ) {
      tempHeat = cvGetReal2D( imgLikelihood, yHeat, xHeat );

      // display a rectange of that colour
      if( tempHeat > 200 ) {
        cvRectangle(specialFrame, cvPoint(xHeat*10, yHeat*10 ), cvPoint(xHeat*10+9, yHeat*10+9 ), CV_RGB ( 0,0,255 ),CV_FILLED, 8, 0);
      }
     
    }
  }
  
  cvShowImage( "Special Frame", specialFrame );
      
}





//! Returns a metric for the depth of a given rectangle
//! Sort of the median, but ignoring zero values
int depthRectangle( CvPoint topleft, CvPoint bottomright ) {

  int i, j, median;
  int totalPixels = 0;
  int hist[256];
  /* Zero the histogram */
  for( i = 0; i < 256; i++ )
    hist[i] = 0;
 
  /* Bound checking */
  if( topleft.x > 640) topleft.x = 640;
  if( topleft.y > 480) topleft.y = 480;
  if( bottomright.x > 640) bottomright.x = 640;
  if( bottomright.y > 480) bottomright.y = 480;

  // for every pixel in the rectangle, store their value in histogram form
  for( j = topleft.y; j < bottomright.y; j++ ) {
    for( i = topleft.x; i < bottomright.x; i++ ) {
      hist[(int) getPixel( stereoFrame, i, j )]++;
      totalPixels++;
    }
  }
  
  /* we want to ignore 0-valued pixels, so subtract them */
  totalPixels = totalPixels - hist[0];
  
  /* find the median */
  i = 0; median = 0;
  while( i < totalPixels / 2 ) {
    median++;
    i = hist[median] + i;
  }
  
  return median;
}



// gets pixel
unsigned char getPixel(IplImage* image,    // image
                        int x,              
                        int y               
                        )
{
  return ((unsigned char*)(image->imageData + image->widthStep*y))[x*image->nChannels];
}
